# 实验1 - 流水线 RISC-V CPU 设计

截止日期：2024 年 10 月 10 日 23:59:59

## 实验目的

-   温故流水线 CPU 设计
-   了解并实现 RV32I 指令集
-   理解旁路优化（Forwarding）

## 实验环境

-   **HDL**：Verilog、SystemVerilog
-   **IDE**：Vivado 2020.2 或更高版本
    - 如果你卸载了之前计组安装的版本，需要自行重新安装。
-   **开发板**：NEXYS A7（XC7A100TCSG324）

## 实验原理

### 指令集概述

RISC-V 是一种开源的精简指令集架构，采用模块化指令设计，它包含基础指令集和扩展指令集两部分。其中基础指令集是最小的指令子集，只要配上相应的特权态指令集，它就能够保证运行起一个操作系统。在完成基础指令集的基础上，开发者可以选择所需要的扩展指令集模块用以完成自己的需求，例如乘除法扩展指令集"M"，浮点指令集"F"等。

目前，最原始的基础指令集有 RV32I 和 RV64I 两种，分别代表32位地址空间和64位地址空间的基础指令集。本次实验中我们需要实现部分 RV32I 非特权指令集。

指令集具体请参考[官方手册](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf)。

### 实现指令

RV32I 非特权指令集指令布局如下图（源自官方手册）所示：

![RV32I 非特权指令集](img/1_RV32I_unprivileged.png){.center}

本次实验需要实现前 37 条指令。

??? Info "整数运算指令（21 条）"
    - **ADDI**
        - **汇编格式**: ADDI rd, rs1, imm
        - **功能定义**: 将寄存器 rs1 的值与**有符号扩展**至 32 位的立即数 imm 相加，结果写入寄存器 rd 中，忽略算术溢出。
    - **SLTI**
        - **汇编格式**: SLTI rd, rs1, imm
        - **功能定义**: 如果寄存器 rs1 的值(signed)小于**有符号扩展**至 32 位的立即数 imm，寄存器 rd 写入 1，否则写入 0。
    - **SLTIU**
        - **汇编格式**: SLTIU rd, rs1, imm
        - **功能定义**: 如果寄存器 rs1 的值(unsigned)小于**有符号扩展**至 32 位的立即数 imm(先符号扩展，然后再当成无符号数进行比较)，寄存器 rd 写入 1，否则写入 0。
    - **XORI**
        - **汇编格式**: XORI rd, rs1, imm
        - **功能定义**: 寄存器 rs1 的值(signed)和**有符号扩展**至 32 位的立即数 imm 按位异或，结果写入寄存器 rd 中。
    - **ORI**   
        - **汇编格式**: ORI rd, rs1, imm
        - **功能定义**: 寄存器 rs1 的值(signed)和**有符号扩展**至 32 位的立即数 imm 按位或，结果写入寄存器 rd 中。
    - **ANDI**
        - **汇编格式**: ANDI rd, rs1, imm
        - **功能定义**: 寄存器 rs1 的值(signed)和**有符号扩展**至 32 位的立即数 imm 按位与，结果写入寄存器 rd中。
    - **SLLI**
        - **汇编格式**: SLLI rd, rs1, shamt
        - **功能定义**: 由立即数 shamt 指定移位量，对寄存器 rs1 的值进行逻辑左移，结果写入寄存器 rd 中。
    - **SRLI**
        - **汇编格式**: SRLI rd, rs1, shamt
        - **功能定义**: 由立即数 shamt 指定移位量，对寄存器 rs1 的值进行逻辑右移，结果写入寄存器 rd 中。
    - **SRAI**
        - **汇编格式**: SRAI rd, rs1, shamt
        - **功能定义**: 由立即数 shamt 指定移位量，对寄存器 rs1 的值进行算术右移，结果写入寄存器 rd 中。
    - **ADD**
        - **汇编格式**: ADD rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值和寄存器 rs2 的值相加，结果写入寄存器 rd 中，忽略溢出。
    - **SUB**
        - **汇编格式**: SUB rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值和寄存器 rs2 的值相减，结果写入寄存器 rd 中，忽略溢出。
    - **SLL**
        - **汇编格式**: SLL rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值逻辑左移寄存器 rs2 低 5 位所指定的移动量，结果写入寄存器 rd 中。
    - **SLT**
        - **汇编格式**: SLT rd, rs1, rs2
        - **功能定义**: 如果寄存器 rs1 的值(signed)小于寄存器 rs2 的值(signed)(注意是有符号比较)，寄存器 rd 写 1，否则写 0。
    - **SLTU**
        - **汇编格式**: SLTU rd, rs1, rs2
        - **功能定义**: 如果寄存器 rs1 的值(unsigned)小于寄存器 rs2 的值(unsigned)，寄存器 rd 写 1，否则写 0。
    - **XOR**
        - **汇编格式**: XOR rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值和寄存器 rs2 的值按位异或，结果写入寄存器 rd 中。
    - **SRL**
        - **汇编格式**: SRL rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值逻辑右移寄存器 rs2 低 5 位所指定的移动量，结果写入寄存器 rd 中。
    - **SRA**
        - **汇编格式**: SRL rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值算术右移寄存器 rs2 低 5 位所指定的移动量，结果写入寄存器 rd 中。
    - **OR**
        - **汇编格式**: OR rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值和寄存器 rs2 的值按位或，结果写入寄存器rd中。
    - **AND**
        - **汇编格式**: AND rd, rs1, rs2
        - **功能定义**: 将寄存器 rs1 的值和寄存器 rs2 的值按位与，结果写入寄存器 rd 中。
    - **LUI**
        - **汇编格式**: LUI rd, imm
        - **功能定义**:将 20 位立即数 imm 写入寄存器 rd 的高 20 位中，寄存器 rd 低 12 位置 0。
    - **AUIPC**
        - **汇编格式**: AUIPC rd, imm
        - **功能定义**: 将 20 位立即数后接 12 位 0 形成 32 位偏移量，再将偏移量与 AUIPC 指令所在的 PC 相加，结果写入寄存器 rd 中。

??? Info "跳转指令（8 条）"
    - **JAL**
        - **汇编格式**: JAL rd, offset
        - **功能定义**: 将 jal 指令对应的 PC 加上 offset<<1（需要先左移一位。注意指令布局中该指令对应的立即数没有包含第 0 位，因为指令对齐的原因，目标指令相对当前指令的偏移末位一定为 0，所以没必要占位，从而扩大了该跳转指令的寻址范围） 的有符号扩展得到跳转的目标地址，然后把 jal 指令所在PC+4 写入寄存器 rd 中。
        (PC_{next} = PC_{current} + (sign\_extend(offset) << 1), Reg[rd] = PC_{current} + 4)
    - **JALR**
        - **汇编格式**: JALR, rd, offset(rs1)
        - **功能定义**: 寄存器 rs1 的值加上有符号扩展的 offset 得到跳转的目标地址，并将目标地址最低位置 0（同样的，指令对齐问题），然后把 jalr 所在PC+4 写入寄存器 rd 中。
        (PC_{next} = Reg[rs1] + sign\_extend(imm),PC_{next}[0] = 0, Reg[rd] = PC_{current} + 4)
    - **BEQ**
        - **汇编格式**: BEQ rs1, rs2, offset
        - **功能定义**: 如果寄存器 rs1 的值和寄存器 rs2 的值相等就发生跳转，跳转地址是有符号扩展$offset<<1$ 加上 BEQ 指令对应的 PC。
    - **BNE**
        - **汇编格式**: BNE rs1, rs2, offset
        - **功能定义**: 如果寄存器 rs1 的值和寄存器 rs2 的值不相等就发生跳转，否则顺序执行，跳转地址是有符号扩 offset<<1 加上 BNE 指令对应的 PC。
    - **BLT**
        - **汇编格式**: BLT rs1, rs2, offset
        - **功能定义**: 如果寄存器 rs1 的值(signed)小于寄存器 rs2 的值(signed)就发生跳转，否则顺序执行，跳转地址是有符号扩展 offset<<1 加上 BLT 指令对应的 PC。
    - **BLTU**
        - **汇编格式**: BLTU rs1, rs2, offset
        - **功能定义**: 如果寄存器 rs1 的值(unsigned)小于寄存器 rs2 的值(unsigned)就发生跳转，否则顺序执行，跳转地址是有符号扩展 imm<<1 加上 BLTU 指令对应的 PC。
    - **BGE**
        - **汇编格式**: BGE rs1, rs2, offset
        - **功能定义**: 如果寄存器 rs1 的值(signed)大于等于寄存器 rs2 的值(signed)就发生跳转，否则顺序执行，跳转地址是有符号扩展 offset<<1 加上 BGE 指令对应的 PC。
    - **BGEU**
        - **汇编格式**: BGEU rs1, rs2, offset
        - **功能定义**: 如果寄存器 rs1 的值(unsigned)大于等于寄存器 rs2 的值(unsigned)就发生跳转，否则顺序执行，跳转地址是有符号扩展 offset<<1 加上 BGEU 指令对应的 PC。

??? Info "访存指令（8 条）"
    - **LB**
        - **汇编格式**: LB rd, imm(rs1)
        - **功能定义**: 寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址从存储器中读取 8 位的值，将其进行有符号扩展为 32 位后写入寄存器 rd 中。
    - **LH**
        - **汇编格式**: LH rd, imm(rs1)
        - **功能定义**: 寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址从存储器中读取 16 位的值，将其进行有符号扩展为 32 位后写入寄存器 rd 中。
    - **LW**
        - **汇编格式**: LW rd, imm(rs1)
        - **功能定义**: 寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址从存储器中读取 32 位的值，写入寄存器 rd 中。
    - **LBU**
        - **汇编格式**: LBU rd, imm(rs1)
        - **功能定义**: 寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址从存储器中读取 8 位的值，将其进行无符号扩展为 32 位后写入寄存器 rd 中。
    - **LHU**
        - **汇编格式**: LHU rd, imm(rs1)
        - **功能定义**: 寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址从存储器中读取 16 位的值，将其进行无符号扩展为 32 位后写入寄存器 rd 中。
    - **SB**
        - **汇编格式**: SB rs2, imm(rs1)
        - **功能定义**: 寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址将寄存器 rs2 的低 8 位的值写入存储器中。
    - **SH**
        - **汇编格式**: SH rs2, imm(rs1)- **功能定义**: 寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址将寄存器 rs2 的低 16 位的值写入存储器中。
    - **SW**
        - **汇编格式**: SW rs2, imm(rs1)
        - **功能定义**:寄存器 rs1 的值和有符号扩展的 imm 相加得到访存地址，根据访存地址将寄存器 rs2 的 32 位的值写入存储器中。

### Forwarding

在流水线的运行过程中，data hazard 是拖累流水线效率的一个重要的因素。data hazard 本质上是读写同一个寄存器所导致的，所以检测 data hazard 只需对流水线中相应流水段中指令的寄存器编号进行比较，就可以判断 data hazard 是否发生。

``` 
add x1, x2, x3
add x4, x4, x1
```
以上示例中，不加干预，第二条指令在 EX 阶段会取到旧的 x1（第一条指令还没 WB）。我们可以检查 EX 和 ID 段的寄存器操作，如果前者的写目标寄存器和后者的源寄存器重合，说明存在 data hazard。

我们总是可以通过 stall 来解决 data hazard。
比如检测到如上的 data hazard 后，就保持 PC 以及 IF/ID，flush 掉 ID/EX 的寄存器两次（相当于插入两条 nop 指令，stall 两次）。

但是这影响流水性能，所以我们再通过 Forwarding 来优化，减少 stall 的次数。
对于这个算术接着算术（add-add）的情况，在第二条指令 EX 阶段的时候，可以将处在 MEM 阶段的第一条指令已经计算出的 x1 前递给 EX 段，加上对应的源操作数选择器，就可以拿到这个正确的值，来避免 stall。


![ID 段 Forwarding 基本实现原理](img/1_forwarding_id.png){.center}
<p style="text-align: center;">图1：ID 段 Forwarding 基本实现原理</p>

如图 1 所示，实现 Forwarding 的基本功能需要在基本流水线的基础上添加两个模块以及相应的多路选择器：

-  Hazard detection unit: 控制 PC 和 IF/ID 流水线寄存器的写入以及 Nop
的插入（stall）。
-  Forwarding unit: 通过比对流水段中的寄存器编号，控制 ALU 前的多路选择器（前递到 EX 段）或者寄存器堆的出口（前递到 ID 段），以实现数据的替换。

**实验给出的框架如图 1，前递到 ID 段**。**具体选择哪一个流水段做 Forwarding，大家可以根据流水段的时序情况做选择。**

## 实验要求

1.  实现 RV32I 中的所有指令（除了 `fence`, `ecall`, `ebreak`）。
2.  实现流水线中的 Forwarding。
3.  通过仿真测试和上板验证。

## 实验步骤

1.  根据 RISC-V 非特权级手册完成部分 RV32I 指令集。
2.  在流水线中加入 Forwarding 机制。
3.  在给定的 SOC 中，加入自己的 CPU，通过仿真测试和上板验证。

本实验中，你要完成的代码均在 `src/lab1/common/cmp_32.v`, `src/lab1/core/HazardDetectionUnit.v`, `src/lab1/core/CtrlUnit.v` 以及 `src/lab1/core/RV32core.v` 中。

* 其中 `HazardDetectionUnit` 模块的代码已经给出了输入输出端口定义，你需要自行设计该模块的逻辑。
* `CtrlUnit`, `RV32core.v` 和 `cmp_32.v` 已经有了部分代码，你需要在其中添加部分逻辑。需要添加的部分已经在代码中用 `to fill sth. in` 标出。

你可以浏览其他框架代码及其注释来熟悉整个流水线的实现。你也可以修改框架代码以适应你的设计，我们鼓励你使用自己的方式实现功能，如有修改请在报告注明。

## 实验现象

本实验的测试代码可见 `src/lab1/all_test.s`，注释中说明了这条指令的 PC 值和执行之后寄存器的变化。你可以通过仿真测试和上板验证来验证你的设计。验收时我们会通过寄存器和 PC 的值检查你的 CPU 是否能够正确执行这段测试代码。

## 注意事项

1.  在做 Forwarding 的时候，请注意在图[1]的 5 级流水线架构下，存在相邻的 load 和一些需要 ALU 操作的指令发生数据冲突，需要额外 stall 一个周期的情况。例如 lw 后紧跟 add，如果存在数据冲突，就需要让 add 指令 stall 一个周期，等 lw 的数据传到 WB 段再 forward 到 EX 段（在 ID 段做 Forwarding 则需要 stall 两个周期）。  
2.  如果相邻的 load 和 store 要做 forwarding，需要增加额外的逻辑。如果没有做 forwarding，则需要 stall 一个周期。

## 思考题

1.  添加了 Forwarding 机制后，是否观察到了 stall 延迟减少的情况？请在测试程序中给出 Forwarding 机制起到实际作用的位置，并给出仿真图加以证明。（只需要贴出一次 Forwarding 机制起效的仿真图片即可）  
2.  在我们的框架中，比较器 `cmp_32` 处于 ID 段。请说明比较器在 ID 对比比较器在 EX 的优劣。（提示：可以从时延的角度考虑）

**注：思考题写入实验报告内。**
